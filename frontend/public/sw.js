// Service Worker para Push Notifications

const CACHE_NAME = 'la-publica-v2';
const STATIC_CACHE = 'la-publica-static-v2';
const DYNAMIC_CACHE = 'la-publica-dynamic-v2';
const IMAGE_CACHE = 'la-publica-images-v2';

// URLs cr√≠ticas para cachear inmediatamente
const CRITICAL_URLS = [
  '/',
  '/manifest.json',
  '/icon-192x192.png',
  '/icon-512x512.png',
  '/offline',
  '/_next/static/css/',
  '/_next/static/chunks/'
];

// URLs que deben cachearse din√°micamente
const CACHE_STRATEGIES = {
  '/api/': 'networkFirst',
  '/dashboard': 'staleWhileRevalidate',
  '/mensajes': 'staleWhileRevalidate',
  '/grupos': 'staleWhileRevalidate',
  '/perfil': 'staleWhileRevalidate',
  '/_next/': 'cacheFirst',
  '/uploads/': 'cacheFirst'
};

// Configuraci√≥n de TTL para diferentes tipos de contenido
const CACHE_TTL = {
  static: 7 * 24 * 60 * 60 * 1000, // 7 d√≠as
  api: 5 * 60 * 1000, // 5 minutos
  images: 30 * 24 * 60 * 60 * 1000, // 30 d√≠as
  dynamic: 24 * 60 * 60 * 1000 // 1 d√≠a
};

// Instalaci√≥n del service worker
self.addEventListener('install', (event) => {
  console.log('üîß Service Worker: Instalando...');
  
  event.waitUntil(
    Promise.all([
      // Cachear recursos cr√≠ticos
      caches.open(STATIC_CACHE)
        .then(cache => {
          console.log('üì¶ Cacheando recursos cr√≠ticos');
          return cache.addAll(CRITICAL_URLS.filter(url => !url.endsWith('/')));
        }),
      
      // Precachear la p√°gina principal
      caches.open(DYNAMIC_CACHE)
        .then(cache => {
          console.log('üè† Cacheando p√°gina principal');
          return cache.add('/');
        })
    ])
    .then(() => {
      console.log('‚úÖ Service Worker instalado correctamente');
      return self.skipWaiting();
    })
    .catch(error => {
      console.error('‚ùå Error instalando Service Worker:', error);
    })
  );
});

// Activaci√≥n del service worker
self.addEventListener('activate', (event) => {
  console.log('üöÄ Service Worker: Activando...');
  
  event.waitUntil(
    Promise.all([
      // Limpiar caches antiguos
      caches.keys().then(cacheNames => {
        console.log('üßπ Limpiando caches antiguos');
        return Promise.all(
          cacheNames.map(cacheName => {
            if (![STATIC_CACHE, DYNAMIC_CACHE, IMAGE_CACHE].includes(cacheName)) {
              console.log('üóëÔ∏è Eliminando cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      
      // Tomar control de todas las pesta√±as
      self.clients.claim()
    ])
    .then(() => {
      console.log('‚úÖ Service Worker activado y en control');
      
      // Notificar a los clientes que el SW est√° listo
      self.clients.matchAll().then(clients => {
        clients.forEach(client => {
          client.postMessage({
            type: 'SW_ACTIVATED',
            version: 'v2'
          });
        });
      });
    })
  );
});

// Interceptar peticiones de red con estrategias avanzadas
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Ignorar peticiones no HTTP/HTTPS
  if (!request.url.startsWith('http')) {
    return;
  }
  
  // Ignorar peticiones del propio SW
  if (url.pathname.startsWith('/sw.js') || url.pathname.startsWith('/_next/static/chunks/webpack')) {
    return;
  }
  
  event.respondWith(handleRequest(request));
});

// Funci√≥n principal para manejar peticiones
async function handleRequest(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;
  
  try {
    // Determinar estrategia de cache
    let strategy = 'networkFirst'; // Por defecto
    
    for (const [pattern, cacheStrategy] of Object.entries(CACHE_STRATEGIES)) {
      if (pathname.startsWith(pattern)) {
        strategy = cacheStrategy;
        break;
      }
    }
    
    // Aplicar estrategia correspondiente
    switch (strategy) {
      case 'cacheFirst':
        return await cacheFirst(request);
      case 'networkFirst':
        return await networkFirst(request);
      case 'staleWhileRevalidate':
        return await staleWhileRevalidate(request);
      default:
        return await networkFirst(request);
    }
  } catch (error) {
    console.error('‚ùå Error en handleRequest:', error);
    return await handleOffline(request);
  }
}

// Estrategia Cache First (para recursos est√°ticos)
async function cacheFirst(request) {
  const url = new URL(request.url);
  const cacheName = url.pathname.includes('uploads/') ? IMAGE_CACHE : STATIC_CACHE;
  const cache = await caches.open(cacheName);
  const cached = await cache.match(request);
  
  if (cached && !isExpired(cached, CACHE_TTL.static)) {
    return cached;
  }
  
  try {
    const response = await fetch(request);
    if (response.ok) {
      // Clonar para poder almacenar y devolver
      const responseClone = response.clone();
      await cache.put(request, responseClone);
    }
    return response;
  } catch (error) {
    // Si hay error de red y tenemos cache (aunque est√© expirado), devolverlo
    if (cached) {
      return cached;
    }
    throw error;
  }
}

// Estrategia Network First (para APIs y contenido din√°mico)
async function networkFirst(request) {
  const cache = await caches.open(DYNAMIC_CACHE);
  
  try {
    const response = await fetch(request);
    if (response.ok) {
      // Solo cachear GET requests exitosos
      if (request.method === 'GET') {
        const responseClone = response.clone();
        await cache.put(request, responseClone);
      }
    }
    return response;
  } catch (error) {
    // Intentar desde cache si la red falla
    const cached = await cache.match(request);
    if (cached) {
      console.log('üì° Red fall√≥, sirviendo desde cache:', request.url);
      return cached;
    }
    throw error;
  }
}

// Estrategia Stale While Revalidate (para p√°ginas principales)
async function staleWhileRevalidate(request) {
  const cache = await caches.open(DYNAMIC_CACHE);
  const cached = await cache.match(request);
  
  // Actualizar en segundo plano
  const networkPromise = fetch(request)
    .then(response => {
      if (response.ok && request.method === 'GET') {
        const responseClone = response.clone();
        cache.put(request, responseClone);
      }
      return response;
    })
    .catch(error => {
      console.error('üîÑ Error actualizando cache:', error);
    });
  
  // Devolver cache inmediatamente si existe
  if (cached && !isExpired(cached, CACHE_TTL.dynamic)) {
    return cached;
  }
  
  // Si no hay cache o est√° muy expirado, esperar a la red
  try {
    return await networkPromise;
  } catch (error) {
    // Si la red falla y tenemos cache (aunque est√© expirado), devolverlo
    if (cached) {
      return cached;
    }
    throw error;
  }
}

// Verificar si una respuesta en cache ha expirado
function isExpired(response, ttl) {
  const dateHeader = response.headers.get('date');
  if (!dateHeader) return false;
  
  const responseTime = new Date(dateHeader).getTime();
  const now = Date.now();
  
  return (now - responseTime) > ttl;
}

// Manejar cuando estamos offline
async function handleOffline(request) {
  const url = new URL(request.url);
  
  // Intentar desde cualquier cache disponible
  const caches_list = [DYNAMIC_CACHE, STATIC_CACHE, IMAGE_CACHE];
  
  for (const cacheName of caches_list) {
    const cache = await caches.open(cacheName);
    const cached = await cache.match(request);
    if (cached) {
      console.log('üì± Sirviendo offline desde cache:', request.url);
      return cached;
    }
  }
  
  // Para navegaci√≥n, devolver p√°gina offline
  if (request.mode === 'navigate') {
    const cache = await caches.open(STATIC_CACHE);
    const offlinePage = await cache.match('/offline');
    if (offlinePage) {
      return offlinePage;
    }
  }
  
  // Para APIs, devolver respuesta JSON de error
  if (url.pathname.startsWith('/api/')) {
    return new Response(
      JSON.stringify({
        error: 'Sin conexi√≥n',
        message: 'Esta funcionalidad requiere conexi√≥n a internet',
        offline: true
      }),
      {
        status: 503,
        statusText: 'Service Unavailable',
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
  }
  
  // Para otros recursos, devolver respuesta de error
  return new Response('Sin conexi√≥n', {
    status: 503,
    statusText: 'Service Unavailable'
  });
}

// Manejar push notifications
self.addEventListener('push', (event) => {
  console.log('üì± Push notification recibida:', event);

  if (!event.data) {
    console.log('‚ùå Push sin datos');
    return;
  }

  let notificationData = {};
  
  try {
    notificationData = event.data.json();
  } catch (e) {
    console.error('‚ùå Error parseando datos push:', e);
    notificationData = {
      title: 'Nueva notificaci√≥n',
      body: event.data.text() || 'Tienes una nueva notificaci√≥n'
    };
  }

  // Configurar opciones espec√≠ficas seg√∫n el tipo de notificaci√≥n
  const {
    type = 'message',
    title = 'La P√∫blica',
    body = 'Nueva notificaci√≥n',
    senderName,
    messageContent,
    conversationId,
    messageId,
    userId
  } = notificationData;

  let finalTitle = title;
  let finalBody = body;
  let actions = [];

  // Personalizar seg√∫n el tipo de notificaci√≥n
  switch (type) {
    case 'new_message':
      finalTitle = `üí¨ ${senderName}`;
      finalBody = messageContent || 'Te ha enviado un mensaje';
      actions = [
        {
          action: 'reply',
          title: '‚úçÔ∏è Responder',
          icon: '/icon-reply.png'
        },
        {
          action: 'mark_read',
          title: '‚úÖ Marcar le√≠do',
          icon: '/icon-check.png'
        }
      ];
      break;
    case 'message_reaction':
      finalTitle = `üòä ${senderName}`;
      finalBody = `Reaccion√≥ a tu mensaje`;
      actions = [
        {
          action: 'view',
          title: 'üëÄ Ver mensaje',
          icon: '/icon-view.png'
        }
      ];
      break;
    case 'call_incoming':
      finalTitle = `üìû Llamada entrante`;
      finalBody = `${senderName} te est√° llamando`;
      actions = [
        {
          action: 'answer',
          title: 'üìû Contestar',
          icon: '/icon-phone.png'
        },
        {
          action: 'decline',
          title: '‚ùå Rechazar',
          icon: '/icon-decline.png'
        }
      ];
      break;
  }

  const options = {
    body: finalBody,
    icon: notificationData.icon || '/icon-192x192.png',
    badge: notificationData.badge || '/badge-72x72.png',
    image: notificationData.image,
    tag: `${type}_${conversationId || 'default'}`,
    data: {
      type,
      conversationId,
      messageId,
      userId,
      senderName,
      url: conversationId ? `/?conversation=${conversationId}` : '/',
      ...notificationData.data
    },
    actions,
    requireInteraction: type === 'call_incoming', // Llamadas requieren interacci√≥n
    silent: notificationData.silent || false,
    vibrate: type === 'call_incoming' ? [300, 100, 300, 100, 300] : [200, 100, 200],
    timestamp: notificationData.timestamp || Date.now(),
    renotify: true
  };

  event.waitUntil(
    self.registration.showNotification(finalTitle, options)
  );
});

// Manejar clicks en las notificaciones
self.addEventListener('notificationclick', (event) => {
  console.log('üëÜ Click en notificaci√≥n:', event);

  const notification = event.notification;
  const data = notification.data || {};
  const action = event.action;

  notification.close();

  // Manejar acciones espec√≠ficas
  switch (action) {
    case 'reply':
      console.log('‚úçÔ∏è Acci√≥n: Responder');
      event.waitUntil(openAppAndNavigate(data.url, 'reply'));
      break;
      
    case 'mark_read':
      console.log('‚úÖ Acci√≥n: Marcar como le√≠do');
      event.waitUntil(markMessageAsRead(data));
      break;
      
    case 'view':
      console.log('üëÄ Acci√≥n: Ver mensaje');
      event.waitUntil(openAppAndNavigate(data.url));
      break;
      
    case 'answer':
      console.log('üìû Acci√≥n: Contestar llamada');
      event.waitUntil(openAppAndNavigate(data.url, 'answer_call'));
      break;
      
    case 'decline':
      console.log('‚ùå Acci√≥n: Rechazar llamada');
      event.waitUntil(declineCall(data));
      break;
      
    case 'dismiss':
      console.log('üö´ Acci√≥n: Descartar');
      return;
      
    default:
      console.log('üè† Acci√≥n por defecto: Abrir app');
      event.waitUntil(openAppAndNavigate(data.url || '/'));
  }
});

// Funci√≥n para abrir la app y navegar
async function openAppAndNavigate(url = '/', action = null) {
  const clients = await self.clients.matchAll({
    type: 'window',
    includeUncontrolled: true
  });

  // Buscar ventana existente
  for (const client of clients) {
    if (client.url.includes(self.location.origin)) {
      // Enviar mensaje para realizar acci√≥n espec√≠fica
      if (action) {
        client.postMessage({
          type: 'NOTIFICATION_ACTION',
          action,
          url
        });
      }
      
      // Navegar si es necesario
      if (url !== '/') {
        client.postMessage({
          type: 'NAVIGATE',
          url
        });
      }
      
      return client.focus();
    }
  }

  // No hay ventana abierta, abrir nueva
  const fullUrl = action ? `${url}?action=${action}` : url;
  return self.clients.openWindow(fullUrl);
}

// Funci√≥n para marcar mensaje como le√≠do
async function markMessageAsRead(data) {
  const { messageId, conversationId, userId } = data;
  
  if (!messageId && !conversationId) {
    console.log('‚ùå No hay ID de mensaje o conversaci√≥n para marcar como le√≠do');
    return;
  }

  try {
    // Primero intentar obtener el token desde IndexedDB o localStorage
    // En un SW real, necesitar√≠as almacenar el token de forma segura
    const response = await fetch('http://localhost:3001/api/messaging/mark-read', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // 'Authorization': `Bearer ${token}` // TODO: Obtener token de forma segura
      },
      body: JSON.stringify({
        messageId,
        conversationId,
        userId
      })
    });

    if (response.ok) {
      console.log('‚úÖ Mensaje marcado como le√≠do');
      
      // Mostrar notificaci√≥n de confirmaci√≥n
      self.registration.showNotification('‚úÖ Mensaje marcado como le√≠do', {
        tag: 'mark_read_success',
        icon: '/icon-192x192.png',
        badge: '/badge-72x72.png',
        silent: true,
        timestamp: Date.now()
      });
    } else {
      console.error('‚ùå Error marcando mensaje como le√≠do:', response.status);
    }
  } catch (error) {
    console.error('‚ùå Error en markMessageAsRead:', error);
  }
}

// Funci√≥n para rechazar llamada
async function declineCall(data) {
  const { conversationId, userId, callId } = data;
  
  try {
    const response = await fetch('http://localhost:3001/api/calls/decline', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        // 'Authorization': `Bearer ${token}` // TODO: Obtener token de forma segura
      },
      body: JSON.stringify({
        callId,
        conversationId,
        userId,
        reason: 'declined_from_notification'
      })
    });

    if (response.ok) {
      console.log('‚úÖ Llamada rechazada');
    } else {
      console.error('‚ùå Error rechazando llamada:', response.status);
    }
  } catch (error) {
    console.error('‚ùå Error en declineCall:', error);
  }
}

// Manejar cierre de notificaciones
self.addEventListener('notificationclose', (event) => {
  console.log('Notificaci√≥n cerrada:', event);
  
  // Aqu√≠ podr√≠as enviar analytics sobre notificaciones cerradas
  const data = event.notification.data || {};
  if (data.trackClose) {
    // Enviar evento de tracking
  }
});

// Sincronizaci√≥n en segundo plano
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(
      // Realizar tareas de sincronizaci√≥n
      console.log('Sincronizaci√≥n en segundo plano')
    );
  }
});

// Manejar mensajes desde la aplicaci√≥n principal
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});